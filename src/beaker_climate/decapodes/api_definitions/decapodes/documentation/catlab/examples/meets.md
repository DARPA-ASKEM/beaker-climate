




# Meets in Preorders


[![](https://img.shields.io/badge/show-nbviewer-579ACA.svg)](https://nbviewer.jupyter.org/github/AlgebraicJulia/Catlab.jl/blob/gh-pages/dev/generated/sketches/meets.ipynb)


Our first example of a concept defined by a universal mapping property is a meet respectively meet.


The first step is our Catlab imports


```julia
using Core: GeneratedFunctionStub
using Test

using Catlab.Theories, Catlab.CategoricalAlgebra, Catlab.Graphics
import Catlab.Theories: compose

using DataStructures
```




# Defining some basic preorders


```julia
@present P(FreeSchema) begin
  (a₁,a₂,a₃,a₄)::Ob
  f::Hom(a₁, a₂)
  g::Hom(a₁, a₃)
  h::Hom(a₂, a₄)
  k::Hom(a₃, a₄)
end
```


```
Presentation{Catlab.Theories.ThSchema.Meta.T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Catlab.Theories.FreeSchema.Ob{:generator}[a₁, a₂, a₃, a₄], Hom = Catlab.Theories.FreeSchema.Hom{:generator}[f, g, h, k], AttrType = Catlab.Theories.FreeSchema.AttrType{:generator}[], Attr = Catlab.Theories.FreeSchema.Attr{:generator}[]), Dict(:a₃ => (:Ob => 3), :f => (:Hom => 1), :k => (:Hom => 4), :a₄ => (:Ob => 4), :a₁ => (:Ob => 1), :a₂ => (:Ob => 2), :g => (:Hom => 2), :h => (:Hom => 3)), Pair[])
```


We can draw a picture of our preorder as a Hasse Diagram.


```julia
to_graphviz(P)
```

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="153pt" height="138pt"
 viewBox="0.00 0.00 153.36 138.25" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 134.25)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-134.25 149.36,-134.25 149.36,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="none" stroke="black" cx="27" cy="-53.59" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-49.89" font-family="Times,serif" font-size="14.00">a₁</text>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="none" stroke="black" cx="118.36" cy="-76.24" rx="27" ry="18"/>
<text text-anchor="middle" x="118.36" y="-72.54" font-family="Times,serif" font-size="14.00">a₂</text>
</g>
<!-- n1&#45;&gt;n2 -->
<g id="edge1" class="edge">
<title>n1&#45;&gt;n2</title>
<path fill="none" stroke="black" d="M52.45,-59.9C61.95,-62.26 72.92,-64.98 83.15,-67.51"/>
<polygon fill="black" stroke="black" points="82.5,-70.96 93.05,-69.97 84.18,-64.16 82.5,-70.96"/>
<text text-anchor="middle" x="64.8" y="-67.51" font-family="Times,serif" font-size="14.00">f</text>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="none" stroke="black" cx="73.17" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="73.17" y="-14.3" font-family="Times,serif" font-size="14.00">a₃</text>
</g>
<!-- n1&#45;&gt;n3 -->
<g id="edge2" class="edge">
<title>n1&#45;&gt;n3</title>
<path fill="none" stroke="black" d="M44.72,-39.93C45.58,-39.27 46.46,-38.59 47.34,-37.91"/>
<polygon fill="black" stroke="black" points="49.48,-40.68 55.27,-31.8 45.21,-35.13 49.48,-40.68"/>
<text text-anchor="middle" x="41.03" y="-27.72" font-family="Times,serif" font-size="14.00">g</text>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="none" stroke="black" cx="72.48" cy="-112.25" rx="27" ry="18"/>
<text text-anchor="middle" x="72.48" y="-108.55" font-family="Times,serif" font-size="14.00">a₄</text>
</g>
<!-- n2&#45;&gt;n4 -->
<g id="edge3" class="edge">
<title>n2&#45;&gt;n4</title>
<path fill="none" stroke="black" d="M100.75,-90.06C99.87,-90.75 98.97,-91.46 98.07,-92.16"/>
<polygon fill="black" stroke="black" points="95.67,-89.6 89.96,-98.53 99.99,-95.11 95.67,-89.6"/>
<text text-anchor="middle" x="104.41" y="-94.91" font-family="Times,serif" font-size="14.00">h</text>
</g>
<!-- n3&#45;&gt;n4 -->
<g id="edge4" class="edge">
<title>n3&#45;&gt;n4</title>
<path fill="none" stroke="black" d="M73.03,-36.17C72.93,-49.73 72.8,-68.51 72.68,-84.02"/>
<polygon fill="black" stroke="black" points="69.18,-84.11 72.61,-94.13 76.18,-84.16 69.18,-84.11"/>
<text text-anchor="middle" x="68.36" y="-48.9" font-family="Times,serif" font-size="14.00">k</text>
</g>
</g>
</svg>


It will be convenient to program with our preorders based on the Hasse Diagram represent as a labeled graph so we convert the Presentation{Schema, Symbol} into a FreeDigram. FreeDiagrams are implemented as an ACSet which you can think of as an in-memory database. ACSets are a key feature of Catlab that allow you to represent many data structures in a common framework.


```julia
g = FreeDiagram(P)
```

<div class="c-set">
<span class="c-set-summary">FreeDiagram{Catlab.Theories.FreeSchema.Ob, Catlab.Theories.FreeSchema.Hom} {V:4, E:4, Ob:0, Hom:0}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">V</th>
      <th style = "text-align: right;">ob</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">a₁</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">a₂</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">a₃</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">a₄</td>
    </tr>
  </tbody>
</table>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
      <th style = "text-align: right;">hom</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">f</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">g</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">h</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">k</td>
    </tr>
  </tbody>
</table>
</div>


To give ourselves a graph-like API for Hasse Diagrams, we define parents and children.


```julia
parents(g, y::Int) = subpart(g, incident(g, y, :tgt), :src)
children(g, x::Int) = subpart(g, incident(g, x, :src), :tgt)
```


```
children (generic function with 1 method)
```


We can compute upsets/downsets with breadth first search.


```julia
function bfs(g, x::Int, f=children)
  explored = falses(nparts(g, :V))
  explored[x] = 1
  q = Queue{Int}()
  enqueue!(q, x)
  while !isempty(q)
    v = dequeue!(q)
    S = f(g,v)
    map(filter(s -> !explored[s], S)) do s
      enqueue!(q, s)
    end
    explored[S] .= true
  end
  return findall(explored)
end
```


```
bfs (generic function with 2 methods)
```


The upset of a preorder element is all the elements that come after it in the preorder.


```julia
upset(g,x) = bfs(g,x,children)
```


```
upset (generic function with 1 method)
```


The downset is the dual notion, which we compute by reversing the role of children and parents.


```julia
downset(g,x) = bfs(g,x,parents)

upset(g, 1)
```


```
4-element Vector{Int64}:
 1
 2
 3
 4
```


We can use upsets to define the less than or equal two relation implied by any Hasse Diagram


```julia
function leq(g::FreeDiagram, x::Int, y::Int)
  return y in upset(g, x)
end
```


```
leq (generic function with 1 method)
```




### Exercise 1


Define a more efficient algorithm for checking whether two elements satisfy the leq relation.


Multiple dispatch allows us to overload the leq function with another method for symbols.


```julia
function leq(g::FreeDiagram, x::Symbol, y::Symbol)
  leq(g, incident(g, x, :ob), incident(g, y, :ob))
end
```


```
leq (generic function with 2 methods)
```


the meet of two elements is the largest element in the intersection of their downsets.


```julia
function meet(g::FreeDiagram, x::Int, y::Int)
  U = downset(g, x) ∩ downset(g,y)
  maxima(g, U)
  return maximum(g, U)
end

function meet(g::FreeDiagram, x, y)
  meet(g, incident(g, x, :ob)[1], incident(g, y, :ob)[1])
end
```


```
meet (generic function with 2 methods)
```


assuming that D is a downset, the maxima are those elements whose children are disjoint from D.


```julia
function maxima(g::FreeDiagram, D::Vector{Int})
  X = Set(D)
  M = filter(D) do x
    Pₓ = children(g, x) ∩ X
    length(Pₓ) == 0
  end
  return M
end

function hastop(g::FreeDiagram, xs::Vector{Int})
  length(maxima(g, xs)) == 1
end

function maximum(g::FreeDiagram, xs::Vector{Int})
  m = maxima(g, xs::Vector{Int})
  if length(m) == 1
    return m[1]
  end
  if length(m) > 1
    all_iso = all(m) do a
      Uₐ = downset(g, a)
      a_le_allb = all(m) do b
        b in Uₐ
      end
      return a_le_allb
    end
    if all_iso
      return  m[1]
    end
  end
  return nothing
end
```


```
maximum (generic function with 1 method)
```


From the definition of minimum, you can see that when you want to do many leq queries in sequence, you can reuse the upsets that you compute with bfs. This is a place where mathematical abstractions don't work well with the operational needs of computer programming. In a mathematical definition you can define x ≤ y as y ∈ upset(x), but in programming, that is inefficient when you want to check a property like for all y in Y, x ≤ y. Programming requires you to reason about not only the correctness of the code, but also the performance. Much of the complexity of software engineering comes from the fact that computational performance requires the programmers to break down their clean abstractions to optimize the code.




### Exercise 2


If you wanted to perform many x ≤ y queries in a loop, you might want to precompute the matrix L where L[i,j] = 1 if and only if i ≤ j in the preorder P. Implement an algorithm that performs this computation in O(V⋅E) time where V is the number of elements in P and E is the number of edges in the corresponding FreeDiagram.




## Testing it out


Let's make sure we get the answers that we expect.


```julia
using Test
@testset "Upsets" begin
  @test upset(g, 3) == [3,4]
  @test upset(g, 2) == [2,4]
  @test upset(g, 1) == [1,2,3,4]
  @test upset(g, 4) == [4]
end
@testset "Downsets" begin
  @test downset(g, 3) == [1,3]
  @test downset(g, 2) == [1,2]
  @test downset(g, 4) == [1,2,3,4]
  @test downset(g, 1) == [1]
end

@testset "Meets" begin
  @test meet(g, 2,3) == 1
  @test meet(g, 1,2) == 1
  @test meet(g, 3,4) == 3
  @test meet(g, 1, 4) == 1
  @test meet(g, 1, 1) == 1
  @test meet(g, 2, 2) == 2
end
```


```
Test.DefaultTestSet("Meets", Any[], 6, false, false, true, 1.737567513835145e9, 1.737567513886187e9, false, "meets.md")
```




## Another Example:


```julia
@present P(FreeSchema) begin
  (a₁,a₂,a₃,a₄, a₅)::Ob
  f::Hom(a₁, a₂)
  g::Hom(a₁, a₃)
  h::Hom(a₂, a₄)
  k::Hom(a₃, a₄)
  l::Hom(a₅, a₂)
end
```


```
Presentation{Catlab.Theories.ThSchema.Meta.T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Catlab.Theories.FreeSchema.Ob{:generator}[a₁, a₂, a₃, a₄, a₅], Hom = Catlab.Theories.FreeSchema.Hom{:generator}[f, g, h, k, l], AttrType = Catlab.Theories.FreeSchema.AttrType{:generator}[], Attr = Catlab.Theories.FreeSchema.Attr{:generator}[]), Dict(:a₃ => (:Ob => 3), :f => (:Hom => 1), :l => (:Hom => 5), :k => (:Hom => 4), :a₄ => (:Ob => 4), :a₁ => (:Ob => 1), :a₂ => (:Ob => 2), :g => (:Hom => 2), :h => (:Hom => 3), :a₅ => (:Ob => 5)…), Pair[])
```


Which can be viewed as a picture:


```julia
to_graphviz(P)
```

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg width="195pt" height="181pt"
 viewBox="0.00 0.00 195.41 180.61" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 176.61)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-176.61 191.41,-176.61 191.41,4 -4,4"/>
<!-- n1 -->
<g id="node1" class="node">
<title>n1</title>
<ellipse fill="none" stroke="black" cx="105.63" cy="-22.03" rx="27" ry="18"/>
<text text-anchor="middle" x="105.63" y="-18.33" font-family="Times,serif" font-size="14.00">a₁</text>
</g>
<!-- n2 -->
<g id="node2" class="node">
<title>n2</title>
<ellipse fill="none" stroke="black" cx="107.93" cy="-100.9" rx="27" ry="18"/>
<text text-anchor="middle" x="107.93" y="-97.2" font-family="Times,serif" font-size="14.00">a₂</text>
</g>
<!-- n1&#45;&gt;n2 -->
<g id="edge1" class="edge">
<title>n1&#45;&gt;n2</title>
<path fill="none" stroke="black" d="M106.17,-40.32C106.44,-49.88 106.79,-61.79 107.11,-72.51"/>
<polygon fill="black" stroke="black" points="103.61,-72.81 107.4,-82.71 110.61,-72.61 103.61,-72.81"/>
<text text-anchor="middle" x="103.64" y="-60.22" font-family="Times,serif" font-size="14.00">f</text>
</g>
<!-- n3 -->
<g id="node3" class="node">
<title>n3</title>
<ellipse fill="none" stroke="black" cx="27" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-14.3" font-family="Times,serif" font-size="14.00">a₃</text>
</g>
<!-- n1&#45;&gt;n3 -->
<g id="edge2" class="edge">
<title>n1&#45;&gt;n3</title>
<path fill="none" stroke="black" d="M78.57,-20.64C74,-20.41 69.18,-20.16 64.4,-19.92"/>
<polygon fill="black" stroke="black" points="64.28,-16.4 54.11,-19.39 63.92,-23.4 64.28,-16.4"/>
<text text-anchor="middle" x="66.49" y="-24.08" font-family="Times,serif" font-size="14.00">g</text>
</g>
<!-- n4 -->
<g id="node4" class="node">
<title>n4</title>
<ellipse fill="none" stroke="black" cx="29.14" cy="-96.71" rx="27" ry="18"/>
<text text-anchor="middle" x="29.14" y="-93.01" font-family="Times,serif" font-size="14.00">a₄</text>
</g>
<!-- n2&#45;&gt;n4 -->
<g id="edge3" class="edge">
<title>n2&#45;&gt;n4</title>
<path fill="none" stroke="black" d="M80.82,-99.46C76.23,-99.22 71.41,-98.96 66.62,-98.7"/>
<polygon fill="black" stroke="black" points="66.48,-95.19 56.3,-98.15 66.1,-102.18 66.48,-95.19"/>
<text text-anchor="middle" x="68.72" y="-102.88" font-family="Times,serif" font-size="14.00">h</text>
</g>
<!-- n3&#45;&gt;n4 -->
<g id="edge4" class="edge">
<title>n3&#45;&gt;n4</title>
<path fill="none" stroke="black" d="M27.5,-36.25C27.75,-45.79 28.08,-57.67 28.37,-68.38"/>
<polygon fill="black" stroke="black" points="24.87,-68.65 28.64,-78.55 31.87,-68.46 24.87,-68.65"/>
<text text-anchor="middle" x="23.43" y="-56.12" font-family="Times,serif" font-size="14.00">k</text>
</g>
<!-- n5 -->
<g id="node5" class="node">
<title>n5</title>
<ellipse fill="none" stroke="black" cx="160.41" cy="-154.61" rx="27" ry="18"/>
<text text-anchor="middle" x="160.41" y="-150.91" font-family="Times,serif" font-size="14.00">a₅</text>
</g>
<!-- n5&#45;&gt;n2 -->
<g id="edge5" class="edge">
<title>n5&#45;&gt;n2</title>
<path fill="none" stroke="black" d="M145.51,-139.36C140.59,-134.33 135.02,-128.63 129.7,-123.18"/>
<polygon fill="black" stroke="black" points="132.18,-120.71 122.69,-116 127.17,-125.6 132.18,-120.71"/>
<text text-anchor="middle" x="140.1" y="-120.07" font-family="Times,serif" font-size="14.00">l</text>
</g>
</g>
</svg>


Or, as tables:


```julia
g = FreeDiagram(P)
```

<div class="c-set">
<span class="c-set-summary">FreeDiagram{Catlab.Theories.FreeSchema.Ob, Catlab.Theories.FreeSchema.Hom} {V:5, E:5, Ob:0, Hom:0}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">V</th>
      <th style = "text-align: right;">ob</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">a₁</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">a₂</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">a₃</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">a₄</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">a₅</td>
    </tr>
  </tbody>
</table>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
      <th style = "text-align: right;">hom</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">f</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">g</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">h</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">k</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">5</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">l</td>
    </tr>
  </tbody>
</table>
</div>




### Test suite


```julia
@testset "meets2" begin
  @test meet(g, 2,3) == 1
  @test meet(g, 1,2) == 1
  @test meet(g, 3,4) == 3
  @test meet(g, 1, 4) == 1
  @test meet(g, 1, 1) == 1
  @test meet(g, 2, 2) == 2
  @test meet(g, 3, 5) == nothing
  @test meet(g, 2, 5) == 5
end
```


```
Test.DefaultTestSet("meets2", Any[], 8, false, false, true, 1.737567513958239e9, 1.737567513958357e9, false, "meets.md")
```




### Exercise 3


Make bigger preorders to test corner cases in the above code. If you find an example that breaks these implementations, please report it.




### Exercise 4


Implement the dual constructions for joins.

